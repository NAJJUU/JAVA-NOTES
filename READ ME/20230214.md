# 내부 클래스(Inner Class)
내부클래스는 클래스 내에 선언된 클래스로 내부 클래스도 클래스이기 때문에 abstract나 final과 같은 제어자를 사용할 수 있고, 멤버 변수들처럼 
private, protected와 같은 접근제어자도 사용이 가능하다.
- 내부 클래스에서 외부 클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄일 수 있다.

## 내부 클래스 종류
- instance class: 외부 클래스의 멤버변수 선언 위치에 선언하며 외부 클래스의 인스턴스 멤버처럼 다루어진다. 
<br>->주로 외부 클래스의 인스턴스 멤버들과 관련되어 작업에 사용될 목적으로 쓰임</br>
- static class: 외부 클래스의 멤버변수 선언위치에 선언하며 외부 블래스의 static 멤버처럼 다루어진다.
<br>주로 외부 클래스의 static멤버, static 메서드에 사용될 목적으로 쓰임</br>

※ Instance 클래스가 바깥 클래스를 외부 참조 함으로써, 만일 외부 클래스는 필요가 없어지고 
내부 클래스만 남아있을경우, 
<br>필요없어진 외부 클래스를 GC 대상으로 삼아 메모리에서 
제거해야 되지만 외부 참조로 내부 클래스와 연결되어 있기 때문에 메모리에서 제거가 안되고 
잔존하게 된다.</br>
->내부 클래스가 외부 클래스의 멤버를 가져와 사용하는 경우가 아닌 경우(내부 클래스가 독립적으로 사용되는 경우) 
내부 클래스를 선언 할 때는 static 키워드를 붙여주는 것이 좋다.

![image](https://user-images.githubusercontent.com/122864238/218683024-da0af2c8-969e-4f85-8ae9-922aaaeadfea.png)
![image](https://user-images.githubusercontent.com/122864238/218683275-79eee788-fc32-4ec8-92fe-341876e758e8.png)


- local class: 외부 클래스의 메서드나 초기화 블럭 안에서 선언하며 선언된 내부에서만 사용할 수 있다.

![image](https://user-images.githubusercontent.com/122864238/218684407-96c742f8-35e1-48fb-a6ee-3079202d93a8.png)

- anonymous class: 클래스의 선언과 객체의 생성을 동시에 하는 이름없는 클래스(일회용)로 클래스의 
선언과 객체의 생성을 동시에 하기 때문에 단 한번만 사용할 수 있고 오직 하나의 객체만 생성할 수 있는 
일회용 클래스이다. 
<br>이름이 없기 때문에 생성자도 가질 수 없고, 단 하나의 클래스를 상속받거나 단 
하나의 인터페이스를 구현해야 한다. </br>
->일반적으로 한번만 생성하고 재생성되지 않는 객체를 만들 
때 익명 함수를 사용한다.
<br>->익명 함수로 클래스 정의와 구현을 동시에 하여 코드 길이를 줄일 수 있어 Runnable이나 
Event Listener 객체를 생성하는데 주로 사용된다.</br>

![image](https://user-images.githubusercontent.com/122864238/218686339-6163881a-5480-4d93-84f9-1effc5b571d3.png)

※ 내부 클래스는 각 내부 클래스의 선언 위치에 따라 변수와 동일한 유효범위와 접근성을 갖게된다.

# 람다식과 함수형프로그래밍
## 람다식(Lambda Expression)
람다식(Lambda Expression)이란 함수를 하나의 식(expression)으로 표현한 것으로 함수를 
람다식으로 표현하면 메소드의 이름이 필요 없기 때문에, 람다식은 익명 함수(Anonymous 
Function)의 한 종류라고 볼 수 있다.
<br>익명함수(Anonymous Function)란 함수의 이름이 없는 함수로, 익명함수들은 모두 일급 객체이며 
1급 객체인 함수는 변수처럼 사용가능하며 매개 변수로 전달이 가능하는 등의 특징을 가지고 있다.</br>

![image](https://user-images.githubusercontent.com/122864238/218690649-06f8d75b-e256-4c2b-a020-854484a12ce4.png)

- 람다식 장점
1. 람다방식은 메소드 명이 불필요하며 괄호()와 화살표 ->를 이용해 함수를 선언한다.
2. 람다식은 불필요한 코드를 줄여 가독성이 좋다.
3. 함수를 만드는 과정없이 한번에 처리할 수 있어 생산성이 높아지며 병렬프로그래밍이 용이하다.
- 람다식 단점
1. 람다를 사용하면서 만든 무명함수는 재사용이 불가능하며 디버깅이 어렵다. 
2. 람다를 남발하면 비슷한 함수가 중복 생성되어 코드가 지저분해질 수 있고 재귀로 만들 경우 부적합하다.
3. 람다식 내에서 사용되는 지역변수는 final이 붙지 않아도 상수로 간주된다.
4. 람다식으로 선언된 변수명은 다른 변수명과 중복될 수 없다.

## 함수형 인터페이스(Functional Interface)
한개의 추상메서드를 가질 수 있는 인터페이스로 함수형 인터페이스를 정의하고 @Functionallnterface를 어노테이션으로 붙여주어야한다.
<br>(@FunctionalInterface 어노테이션은 함수형 인터페이스에 부합하는지 확인하기 위한 어노테이션)</br>
->@Functionallnterface 어노테이션은 함수를 1급 객체처럼 다룰 수 있게 해주는 어노테이션으로, 
인터페이스에 선언하여 단 하나의 추상 메소드만을 갖도록 제한하는 역할을 한다. 
<br>->@FunctionalInterface 어노테이션을 한 인터페이스에 여러 개의 함수를 선언하면 컴파일 에러가 발생한다.</br>
->함수를 변수처럼 선언할 수 있고 코드를 간결하게 작성할 수 있다.
<br>※ 람다식으로 생성된 순수 함수는 함수형 인터페이스로만 선언이 가능하기 때문에 함수형 인터페이스를 사용한다.</br>

![image](https://user-images.githubusercontent.com/122864238/218692640-0b95b3db-8999-4760-a963-95c7146b182a.png)

## Function
java.util.function의 인터페이스로 함수형 인터페이스의 한 종류이다.
<br>apply()라는 하나의 매개변수를 갖는 메서드가 있으며, 리턴값도 존재하며 이 인터페이스는 Function<T,R>로 정으되어 있어, Generic 타입을 두개 갖고 있는데 
앞에 있는 T는 입력 타입, 뒤에 있는 R은 리턴타입을 의미한다. </br>
->즉 변환을 할 필요가 있을 때 이 인터페이스를 사용한다.

![image](https://user-images.githubusercontent.com/122864238/218694161-ae3ca028-3529-495f-b31b-97e40d1a5ad9.png)

# Runnable과 Thread
- Runnable은 인터페이스이고 Thread는 클래스.
- Runnable로 하나의 thread(task)를 만들 수 있음->여러개의 Runnable을 만들면 멀티 thread 만들기 가능
- Thread 클래스를 확장하는 것이 실행 방법이 미세하게 더 간단하지만 자바에서는 다중 상속을 
허용하지 않기 때문에, Thread 클래스를 확장하는 클래스는 다른 클래스를 상속받을 수 없다. 
- 반면에 Runnable 인터페이스를 구현했을 경우에는 다른 인터페이스를 구현할 수 있을 뿐만 아니라, 다른 클래스도 상속받을 수 있다. 
<br>->해당 클래스의 확장성이 중요한 상황이라면 Runnable 인터페이스를 구현하는 것이 더 바람직하다. </br>
