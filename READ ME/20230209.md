## DBMS(Database Management System)
데이터의 집합을 만들고, 저장 및 관리할 수 있는 기능들을 제공하는 응용 프로그램으로 데이터의 관리에 특화된 프로그램이다.
<br>->oracle, MySQL, postgreSQL 등이 있음</br>

# 패키지(Package)
패키지는 비슷한 성격의 자바 클래스들을 모아 놓은 자바의 디렉토리이다.

## JAVA lang 패키지 
- JAVA의 lang 패키지는 JAVA 프로그래밍에 필요한 가장 기본적인 클래스들이 모여있는 패키지 
- lang 패키지는 import 구문 없이도 자동으로 프로그램에 포함된다.
<br>->다른 패키지들은 import 구문으로 호출해야 사용할 수 있음</br>

## JAVA I/O 패키지
- Java I/O 패키지는 데이터 스트림, 직렬화 및 파일 시스템을 통한 시스템 입력 및 출력을 제공한다.
<br>->파일 입출력과 관련된 클래스들로 구성되어 있음</br>
- I/O: Input과 Output의 약자로 입출력을 의미한다.
<br>->간단한 예로 키보드로 텍스트를 입력하고, 모니터로 입력한 텍스트를 출력하는 것임</br>
- 스트림(Stream): 어느 한쪽에서 다른 쪽으로 데이터를 보내려면 일종의 다리 역할을 하는 것이 필요한데 그게 스트림이다.
<br>->스트림은 단방향통신만 가능해 하나의 스트림으로 입출력을 동시에 처리할 수 없음</br>
※ 입출력을 동시에 처리하고 싶으면 입력 스트림 1개, 출력 스트림 1개 총 2개의 스트림을 생성해야한다.
![image](https://user-images.githubusercontent.com/122864238/217757915-43ffd8a5-fa71-4f6b-94e2-cc2b33f6eb90.png)
- InputStream, OutputStream 둘 다 바이트 기반 입출력 스트림의 최상위 클래스로 추상 클래스로 
관련된 모든 바이트 기반 입출력 스트림은 이 클래스를 상속받아서 만들어진다.
<br>->수업시간에 짜본 코드인 UserInfoClient에서 FileInputStream 객체를 InputStream을 매개변수로 하는 부분에 넣을 수 있었음</br>

![image](https://user-images.githubusercontent.com/122864238/217760877-43b820d9-423b-444d-8ab5-c0f1ae0acb7b.png)

# 에러의 종류
에러는 크게 컴파일 에러와 런타임 에러로 구분할 수 있다.
- 컴파일 에러: 컴파일 과정에서 일어나는 에러로 기본적으로 자바 컴파일러가 문법 검사를 통해서 오류를 잡아내 주기때문에 
<br>컴파일러가 알려주는 오류를 수정하면 성공적으로 컴파일을 해서 프로그램을 실행할 수 있다.</br>
- 런타임 에러: 실행 과정(runtime)에서 오류가 발생하는 것으로 자바에서는 예외(Exception)와 에러(Error) 두 가지로 구분하여 대응하고 있다.

## 에러(ERROR)
메모리 부족(OutOfMemoryError), 스택오버플로우(StackOverFlowError)처럼 JVM이나 하드웨어 등의 기반 시스템의 
문제로 발생하는 것으로 발생했을 때를 대비해서 프로그래머가 뭔가 할 수 있는게 없다. 
<br>->발생하는 순간 무조건 프로그램은 비정상 종료되기 때문에 애초에 발생하지 않도록 해야 한다.</br>

## 예외(Exception)
발생하더라도 프로그래머가 미리 적절한 코드를 작성해서 프로그램이 비정상적으로 종료되지 않도록 핸들링 해줄 수 있다.
<br>Exception은 Checked Exception과 UnChecked Exception 2가지로 나눌 수 있다</br>

1. Checked Exception: RuntimeException을 제외한 모든 Exception은 모두 Checked Exception로 
try~catch문 같은 예외 처리를 해줘야 컴파일이 되는데 Exception은 컴파일 시 발생하는 예외이기 때문이다.
<br>->IOException FileNotFoundException이 여기에 속함</br>
  - thows: 자신을 호출하는 메소드에 예외처리의 책임을 넘긴다.
  - thow: 개발자가 직접 사용자정의 예외를 발생시키고싶을 때 사용한다-> try~catch문 사용해주어야 함
2. UnChecked Exception: 진짜 실행할 때 발생하는 예외

## 객체지향 vs 절차지향
- 절차지향(Procedural Programming)
<br>순차적인 처리가 중요시 되며 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법으로 대표적인 절차지향 언어에는 
C언어가 있다. </br>
컴퓨터의 처리구조와 유사해 실행속도가 빠르지만 유지보수가 어렵고 실행 순서가 정해져 있으므로 코드의 순서가 바뀌면 동일한 결과를 보장하기 어렵다. 또한 
디버깅도 어렵다.
- 객체지향(Object Oriented Programming) 
<br>실제 세계를 모델링하여 소프트웨어를 개발하는 방법으로 개발하려는 것을 기능별로 묶어 모듈화를 함으로써 같은 기능을 중복으로 
연산하지 않거나 모듈을 재활용하기 때문에 유지보수에 유리하다.</br>
코드의 재활용성이 높고 코딩이 절차지향보다 간편하며 디버깅이 쉽지만 처리속도가 절차지향보다 느리고 설계에 많은 시간소요가 들어간다.

※ 절차지향은 순차적으로 실행에 초점이 되어 있으며 데이터를 중심으로 함수를 구현하고 객체지향은 객체간의 관계/조직에 초점을 두고 있으며 기능을 중심으로 메서드를 구현하게 된다.

## 자료구조 형태
- stack: first in last out
- queue: first in first out
Collection 인터페이스는 List, Set, Queue로 크게 3가지 상위 인터페이스로 분류할 수 있다.
Collection을 부모로 크게 List와 Set, Queue로 분류되고 이들은 다 인터페이스이다.
List의 분류에는 Stack과 ArrayList가 있는데 Stack과 ArrayList는 클래스이다.

![image](https://user-images.githubusercontent.com/122864238/217767902-e1b127df-7388-4919-8bdd-afc403793524.png)
전체는 아니고 내가 배운것들로만 간단히 도식화한 것.

# 논리적 동등
같은 객체든 다른 객체든 객체 저장 데이터가 동일하다.
- 논리적 동등의 조건: 두 객체의 hashcode()가 같아야하고 equals() 시 true가 나와야 함

## equals()
Object 클래스의 equals()는 비교 연사자인 == 과 동일한 결과를 리턴한다. 
<br>오로지 참조값(객체의 주소값)이 같은지, 다시말하면 동일 객체인지를 확인하는 기능으로 두 객체를 동등 비교할 때 equals() 메소드를 흔히 사용한다. </br>
equals() 메소드를 오버라이딩(overriding)하여 두 객체를 비교해서 논리적으로 동등하면 true를 리턴하고 그렇지 않으면 false를 리턴하도록 한다. 

@@@@@@@@@@@@@@@@@@지금껏 내가 잘못 알고 있던 사실!!!!@@@@@@@@@@@@@@@@@@@@
<br>논리적으로 동등하다는것은 둘의 참조값이 다르더라도 객체 내부 value는 같다는것을 의미하는데 지금까지 equals()는 value가 같으면 true를 반환하는 줄 알았다.
그런데 나는 지금껏 equals()를 String 클래스에만 사용해서 가능했던 거였다.</br>
String이나 Integer는 오버라이딩을 하지않아도 자동적으로 오버라이딩 되어있어 value값이 동일하면 true를 반환해준다.

- 동일성 비교는 == 비교다. 객체 인스턴스의 주소 값을 비교한다.
- 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다(equals를 오버라이드하고 난 다음)

## hashcode()
객체를 식별하는 하나의 정수값으로 Object의 hashCode() 메소드는 객체의 메모리 번지를 이용해서 해시코드를 만들어 리턴하기 때문에 객체 마다 다른 
값을 가지고 있다.

------------------------------------------------------------------------------------------------------------------------------------------------------

논리적 동등은 equals()가 true가 나와야하고 hashcode가 동일해야하므로 (오버라이딩 한) equals()가 true가 나온다면 
hashcode도 오버라이딩해서 동일한 값으로 만들어준다.

![image](https://user-images.githubusercontent.com/122864238/217775592-2d2e06a5-9e49-489c-b0cb-4f1fef47e6df.png)


