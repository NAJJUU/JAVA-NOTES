## 상속에서 자동형변환
- 자식클래스는 부모클래스의 것을 포함하고 있기 때문에 부모타입에 모든 자식 객체가 대입될 수 있다.
<br>  ->부모타입 변수는 자식타입의 생성자를 통해 객체를 생성할 수 있고 이때 자동으로 타입 변환이 일어난다.</br>
- 자식타입이 부모타입으로 자동타입변환된 이후에 변수는 자식객체를 참조하지만 변수로 접근가능한 멤버는 부모 클래스 멤버로만 한정된다.
<br>  ->부모클래스에 없고 자식 클래스에만 있는 멤버에 접근할 수 없다.</br>
  ->사용할 수 있는 변수는 부모의 것만 가능하지만 자식 클래스에서 오버라이딩되어 있는 부분은 자식 객체의 것을 사용한다.
1. 부모 = new 부모 -> 부모의 것 사용
2. 부모 = new 자식 -> 부모가 가지고 있는 변수들이 자식의 값으로 오버라이딩
	<br>(자식만 가지고 있는 변수는 사용할 수 없음)</br>
3. 자식 = new 자식 -> 자식의 것 사용
4. 자식 = new 부모 -> 사용 불가

   ![image](https://user-images.githubusercontent.com/122864238/217195081-1804dc93-2f5a-4969-a2e3-15835fd46bf7.png)
<br>※ 자식 클래스에서 오버라이드 된 메서드에 자식의 멤버 변수가 있더라도 부모클래스로 자동 형변환된 객체에서 사용 할 수 있다.</br>
※ 부모 클래스에는 존재하지 않지만 자식 클래스에 존재하는 메서드를 사용하고 싶다면 강제 형변환을 해주어야한다.
<br>   ->강제 형변환 시킬때는 원래 자식객체로 생성된 경우에만 가능하다.</br>

## Private vs Protected
- private: 다른 클래스 뿐만 아니라 부모 자식간의 클래스에서도 접근할 수 없다.
- protected: 다른 클래스에서는 접근하지 못하지만 부모 자식간의 클래스에서는 접근할 수 있다.

변수를 private이나 protected로 접근 제한을 두어도 생성자에서 매개변수로 사용하면 set을 통한 초기화방식 필요없이 객체 생성할 때 바로 사용할 수 있다.
<br>->객체생성 후 변수를 다른값으로 할당할 때는 set 필요</br>

## 어노테이션(Annotation)=메타데이터
- 저장된 데이터 그 자체는 아니지만 해당 데이터에 대한 정보를 갖고 있는 데이터를 의미한다. 즉, DB 내의 데이터에 대한 데이터의 소유, 데이터의 크기에 관련된 정보들이다.
<br>->애플리케이션이 처리해야 할 데이터가 아니라 컴파일 과정과 실행 과정에서 코드를 어떻게 컴파일하고 처리할 것인지 알려주는 정보</br>
- 어노테이션 자체는 아무런 동작을 가지지 않는 표식이지만 리플렉션을 이용해서 어노테이션의 적용 여부와 엘리먼트 값을 읽고 처리할 수 있다.

## has-a vs is-a의 중심 의미
- has-a: 내 클래스에서 다른 클래스를 통해 생성된 객체를 멤버변수로서 사용
- is-a: 다른 클래스를 내 클래스의 중심이 되어 그 클래스에서 확장하여 사용

